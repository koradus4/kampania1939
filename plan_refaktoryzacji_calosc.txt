Plan refaktoryzacji projektu Alternatywna Kampania Wrześniowa 1939
Cel i założenia refaktoryzacji
Celem refaktoryzacji jest przeorganizowanie kodu gry strategicznej Alternatywna Kampania Wrześniowa 1939 w sposób, który poprawi czytelność i ułatwi dalszy rozwój projektu. Należy zachować pełną dotychczasową funkcjonalność (w szczególności działający edytor mapy i żetonów), a jednocześnie przygotować projekt pod implementację nowych systemów opisanych w dokumentacji koncepcyjnej. Refaktoryzacja będzie opierać się na założeniach z pliku dokumentacyjnego plan_prototypu_gry_kampania_wrzesniowa_1939.txt – dzięki temu nowa struktura kodu uwzględni docelowe mechaniki gry (tury, ekonomia, sojusze, rozkazy, zwiad, widoczność itp.). Główne założenia refaktoryzacji:
Wprowadzenie uporządkowanej struktury katalogów (podział na moduły takie jak core, engine, gui, data, assets itp.) zgodnie z dobrymi praktykami organizacji projektów. Dzięki temu każdy segment kodu będzie miał jasno określoną odpowiedzialność, co ułatwi nawigację i utrzymanie projektu​
REDDIT.COM
.
Usunięcie duplikatów kodu i zasobów: wszelkie powielone pliki (np. zduplikowane katalogi z ikonami żetonów) zostaną scalone do pojedynczego źródła prawdy, zgodnie z zasadą DRY (“Don’t Repeat Yourself”) zakładającą, że każda informacja w systemie powinna istnieć tylko w jednym miejscu​
MEDIUM.COM
.
Stworzenie szkieletu brakujących systemów opisanych w dokumentacji koncepcyjnej (tury z podturami, ekonomia, sojusze, rozkazy, zwiad/naloty, widoczność jednostek). Szkielety będą zawierały podstawowe klasy i metody (na razie puste lub uproszczone) definiujące interfejs tych mechanik, co umożliwi ich stopniowe wypełnianie logiką w przyszłości.
Przygotowanie głównego punktu startowego (main.py) uruchamiającego grę z prostym menu GUI (np. w Tkinter), z opcjami typu Nowa gra, Edytor mapy, Edytor żetonów, Wyjście. Ma to ułatwić uruchamianie projektu z poziomu środowiska (np. VS Code) oraz integrację poszczególnych modułów.
Zachowanie działania edytora mapy i żetonów – po reorganizacji plików, edytory te nadal muszą działać jak dotychczas. W razie potrzeby zostaną dostosowane ścieżki do plików czy importy, tak by edytory korzystały z nowej lokalizacji modułów i zasobów.
Przygotowanie infrastruktury pod planowane moduły rozszerzeń, takie jak dostępność (dla niewidomych/niesłyszących graczy) oraz mikrotransakcje. Choć te funkcjonalności nie są teraz zaimplementowane, projekt zostanie ustrukturyzowany tak, by łatwo można je było dodawać – np. przez wydzielenie osobnych modułów/klas, które w przyszłości obsłużą te aspekty.
W dalszych sekcjach przedstawiono szczegółowy plan refaktoryzacji, krok po kroku, wraz z proponowaną nową strukturą katalogów, opisem modyfikacji i uzasadnieniem zgodnym z najlepszymi praktykami tworzenia gier i oprogramowania.
Nowa struktura katalogów
Obecna struktura projektu zostanie zmieniona na modułową architekturę opartą o logiczny podział na warstwy. Celem jest utrzymanie głównego katalogu projektu w czystości i posegregowanie kodu według odpowiedzialności​
REDDIT.COM
. Poniżej przedstawiono proponowaną strukturę katalogów po refaktoryzacji:
core/ – Rdzeń logiki gry: podstawowe klasy i elementy mechaniki niezależne od interfejsu użytkownika. Mogą tu trafić np. definicje jednostek, mapa (reprezentacja heksagonalnej siatki), obsługa stanu gry, ogólne narzędzia i utilsy. To, co stanowi fundament rozgrywki.
engine/ – Silnik gry i systemy rozgrywki: implementacje konkretnych systemów i reguł gry. Znajdą się tutaj moduły odpowiadające za poszczególne mechanizmy (tury, ekonomia, sojusze, rozkazy, zwiad, widoczność, walka, ruch itd.). Każdy z tych aspektów będzie wydzielony w osobnej jednostce modułowej, co ułatwi rozwój i modyfikacje bez wpływania na inne części.
gui/ – Interfejs użytkownika: wszystko, co dotyczy grafiki i interakcji z graczem. W naszym przypadku będą to okna Tkintera, kontrolki, pętle zdarzeń, a także edytor mapy i edytor żetonów (które są narzędziami graficznymi). Kod GUI będzie odwoływał się do logiki z core/engine, ale sam nie będzie zawierać logiki gry – tylko obsługę wyświetlania i wejścia.
data/ – Dane statyczne i pliki konfiguracyjne: tutaj umieszczone zostaną pliki z danymi, które nie są kodem wykonawczym. Przykładowo: scenariusze, zapisane mapy, profile graczy, konfiguracje jednostek (np. w formacie JSON/CSV), itp. (zgodnie z ideą, że wszystko potrzebne grze, co nie jest kodem, trafia do data​
REDDIT.COM
). Dzięki temu dane będą odseparowane od kodu – łatwiej je podmieniać lub edytować bez ryzyka naruszenia logiki.
assets/ – Media i zasoby: pliki graficzne (ikonki jednostek, żetonów, tła map), dźwięki, muzyka, czcionki – czyli wszystko, co jest zasobem multimedialnym. W trakcie refaktoryzacji szczególną uwagę zwrócimy na ujednolicenie tego katalogu – np. scalenie powtarzających się folderów z żetonami do jednego wspólnego zasobu.
accessibility/ – Dostępność: (opcjonalny katalog na tym etapie) zawierający zalążki rozwiązań zwiększających dostępność gry. Można tu umieścić np. moduł screen_reader_interface.py lub audio_descriptions.py, które w przyszłości posłużą do obsługi graczy niewidomych (poprzez syntezę mowy) czy niesłyszących (np. napisy do zdarzeń dźwiękowych). Na razie będą to szkielety z ewentualnymi przykładowymi funkcjami.
store/ lub microtransactions/ – Mikrotransakcje: podobnie jak powyżej, moduł przygotowany pod przyszłe funkcje mikropłatności. Może zawierać np. plik store.py z klasą Store lub PurchaseManager mającą metody do weryfikacji licencji, odblokowywania dodatków itp. (póki co zaimplementowane szczątkowo lub jako mock).
pliki główne projektu: main.py (uruchomienie gry, menu główne), ewentualnie skrypty pomocnicze. W głównym katalogu mogą też znaleźć się pliki README, licencje, konfiguracja (np. requirements.txt jeśli używamy pip, choć tu raczej biblioteki standardowe jak Tkinter).
inne podkatalogi według potrzeb: np. editor/ jeśli edytor miałby być całkiem wydzielony, jednak w tym planie zakładamy, że edytor mapy/żetonów zostanie włączony do gui/ jako część interfejsu narzędziowego gry.
Taka struktura oddziela od siebie różne aspekty projektu. Jak zauważono w dyskusjach programistów, ważne jest logiczne grupowanie powiązanych elementów, przy zachowaniu balansu między zbyt monolitycznymi a zbyt rozdrobnionymi modułami​
REDDIT.COM
. Dzięki temu nowy program będzie łatwiejszy do zrozumienia nawet po dłuższej przerwie w pracach – foldery są nazwane tak, że wskazują, gdzie szukać danego rodzaju funkcjonalności, co zwiększa czytelność i utrzymywalność kodu. Przykład: W katalogu core można umieścić np. moduł units.py z klasą bazową Unit oraz definicjami jednostek (czołgi, piechota etc.), a w engine osobny moduł combat.py zajmujący się logiką walki pomiędzy obiektami Unit. Dzięki temu warstwa definicji jest oddzielona od warstwy mechaniki. Podobnie, pliki graficzne żetonów trafią do assets/tokens/, a ich spis (np. lista dostępnych jednostek z przypisanymi grafikami) do data/tokens.json. Kod GUI (np. gui/token_editor.py) będzie korzystał z tych danych i zasobów, ale nie będzie ich duplikował. Każdy podkatalog otrzyma plik __init__.py, aby Python traktował go jako pakiet. Po przeniesieniu plików, wszystkie ścieżki importów w kodzie muszą zostać zaktualizowane – np. jeśli wcześniej coś importowało moduł map.py, który został przeniesiony do core/map.py, to import zmieni się na from core import map (lub lepiej from core.map import Map odpowiednio do struktury kodu). Aktualizacje importów należy przeprowadzić ostrożnie, aby żadna zależność nie została pominięta. Warto skorzystać z mechanizmów refaktoryzacji w edytorze/IDE lub wyszukiwania tekstowego, by znaleźć wszystkie wystąpienia starej nazwy modułu i zmienić na nową.
Eliminacja duplikatów i ujednolicenie danych
Podczas analizy projektu zauważono obecność duplikatów – np. wielokrotnie zduplikowane katalogi z żetonami (prawdopodobnie kopie tych samych ikon jednostek w różnych miejscach projektu) oraz ewentualnie zduplikowany kod pełniący podobne funkcje. Refaktoryzacja zakłada usunięcie takich powtórzeń i ustanowienie pojedynczych źródeł prawdy dla danych i funkcjonalności. Zastosujemy tutaj zasadę DRY (Don't Repeat Yourself), która mówi, że każdy element wiedzy (logika, dane) powinien być zdefiniowany tylko raz w systemie​
MEDIUM.COM
. Duplikacja prowadzi do rozbieżności (np. aktualizacja jednego pliku żetonu może nie być przeniesiona do jego duplikatu) oraz niepotrzebnie zwiększa objętość projektu. Przykładowe działania w tym kroku:
Scalenie grafik żetonów: jeśli istnieje wiele kopii tych samych plików graficznych jednostek, zostaną one zebrane do jednego katalogu assets/tokens/. Wszystkie odniesienia w kodzie do plików żetonów zostaną skierowane do tej jednej lokalizacji. Dzięki temu zmiana grafiki czy dodanie nowego żetonu wymaga edycji w tylko jednym miejscu.
(Uwaga: jeśli w starym projekcie różne katalogi żetonów były wykorzystywane przez różne moduły, trzeba prześledzić, czy nie różniły się zawartością. Jeśli tak, należy przygotować jeden pełny zestaw zawierający unikalne elementy z wszystkich kopii.)
Unifikacja danych jednostek i map: możliwe, że istnieją powielone pliki konfiguracyjne lub definicje (np. dwa różne pliki opisujące te same jednostki). Zostaną one złączone w jeden spójny plik w data/. W razie konfliktów (np. różne parametry dla tej samej jednostki w różnych miejscach) warto zajrzeć do dokumentacji koncepcyjnej, aby wybrać właściwą wersję lub ujednolicić parametry.
Usunięcie zbędnych kopii kodu: jeżeli ten sam kod (funkcja, klasa) występuje w kilku miejscach, zostanie wydzielony do jednej funkcji/klasy w odpowiednim module, a inne miejsca będą z niego korzystać. Na przykład, jeśli obsługa odczytu pliku mapy jest zaimplementowana dwa razy w dwóch modułach, wydzielimy ją do jednej funkcji w module core/map.py i z obu miejsc wywołamy ten sam kod. To zapewni spójność działania i łatwiejsze poprawki błędów (poprawiając jedną funkcję, poprawiamy działanie w całym projekcie).
Realizując te zmiany, będziemy mieć na uwadze, by nie utracić żadnych danych ani funkcji. Dlatego przed usunięciem czegokolwiek, wykonamy porównanie zawartości duplikatów. Po scaleniu danego zasobu lub fragmentu kodu, przetestujemy funkcjonalność zależną (np. wczytanie żetonu do mapy) aby upewnić się, że odwołuje się do nowej, właściwej lokalizacji. Dzięki eliminacji duplikatów projekt stanie się lżejszy i mniej podatny na błędy. Każda zmiana będzie dokonywana w jednym miejscu, co zmniejsza ryzyko pominięcia czegoś. Jak zauważono w literaturze, utrzymywanie jednej definicji dla każdego elementu upraszcza testowanie i utrzymanie – kod staje się mniej podatny na niespójności i łatwiejszy do rozszerzania​
MEDIUM.COM
.
Szkielety brakujących systemów
Koncepcja gry opisana w dokumentacji przewiduje szereg systemów rozgrywki, które dotąd nie zostały zaimplementowane lub istnieją w szczątkowej formie. Refaktoryzacja obejmie dodanie szkieletu (struktur klas, metod, modułów) dla każdego z tych systemów, tak aby przygotować miejsce na pełną implementację w przyszłości. Na obecnym etapie będą to minimalne implementacje (stuby) – wystarczające, by zachować integralność projektu i umożliwić wywołanie ich bez błędów, ale bez pełnej logiki. Takie podejście pozwala stopniowo rozwijać grę, stosując zasadę "Keep it simple and scale as you go" – zaczynamy od prostej struktury, którą będziemy wypełniać szczegółami później​
REDDIT.COM
.
System tury i podtur (głównodowodzący + generałowie)
W grach turowych kluczowym elementem jest mechanizm upływu czasu i kolejności działań. Zgodnie z opisem, tura ma być podzielona na fazę głównodowodzącego i fazy poszczególnych generałów. Szkielet systemu tur będzie zarządzał tymi etapami. Proponowane zmiany:
Utworzenie modułu engine/turns.py (lub engine/turn_manager.py) zawierającego klasę np. TurnManager lub TurnSystem. Klasa ta będzie odpowiadać za sekwencyjne przeprowadzenie tury gry.
Klasa TurnManager może zawierać:
Pole current_turn (numer bieżącej tury) oraz mechanizm inkrementacji tury.
Metodę start_turn() inicjującą nową turę – tutaj można umieścić wywołanie fazy głównodowodzącego na początku.
Metodę process_commander_phase() obsługującą czynności Naczelnego Wodza (np. przydział punktów, wydawanie rozkazów – na razie może wypisywać komunikat lub logować, że ta faza nastąpiła).
Metodę process_generals_phase() iterującą przez listę generałów i inicjującą ich podtury (np. wywołując metodę general.take_turn() dla każdego generała). Na tym etapie generałowie mogą być reprezentowani prostą klasą General (np. w module core/units.py lub osobnym core/actors.py), posiadającą podstawowe atrybuty i metodę take_turn() – obecnie może być ona pusta lub wypisująca placeholder.
Zaimplementowanie minimalnej logiki zmiany faz: np. TurnManager.end_turn() kończąca turę i ewentualnie przygotowująca następną.
W efekcie, chociaż faktyczne działania w każdej fazie nie są jeszcze określone, gra będzie miała strukturę pozwalającą na przełączanie tur i obsługę wielu podtur w ramach jednej rundy. W przyszłości w metodach tych klas zostaną dodane konkretne akcje zgodnie z dokumentacją (np. w fazie głównodowodzącego przydział punktów ekonomicznych i wydanie rozkazów generałom, a w fazach generałów – ruchy jednostek, ataki itp.). Aby zintegrować ten system z resztą gry, główna pętla rozgrywki (być może w klasie Game lub podobnej w core) powinna korzystać z TurnManager do kontroli przebiegu tury. Na razie, jeśli gra nie posiada jeszcze głównej pętli, można wstawić wywołanie np. TurnManager.start_turn() gdzieś w logice startu nowej gry, żeby pokazać, że struktura istnieje.
System ekonomii (punkty ekonomiczne, zaopatrzenie)
System ekonomiczny dotyczy zarządzania zasobami – w kontekście kampanii wojennej mogą to być punkty ekonomiczne (służące np. do zakupu nowych jednostek, uzupełnień) oraz zaopatrzenie armii (dostarczanie paliwa, amunicji, żywności jednostkom). W refaktoryzacji utworzymy szkielet, który na razie będzie śledzić te wartości i pozwoli w przyszłości rozbudować ich wpływ na grę. Proponowane zmiany:
Dodanie modułu engine/economy.py z klasą EconomySystem (lub podobną nazwą). Ta klasa będzie gromadzić i udostępniać informacje o zasobach.
Główne odpowiedzialności klasy EconomySystem:
Przechowywanie punktów ekonomicznych dla każdej strony konfliktu. To może być np. słownik {faction: points} lub osobne pola dla Polski, Niemiec itp., w zależności od liczby stron w grze. Na starcie gry wartości mogą być ustawiane według scenariusza (np. odczytane z pliku w data/).
Metody do modyfikacji punktów: add_points(faction, amount) i spend_points(faction, amount) – ta druga powinna sprawdzać, czy dana strona ma wystarczającą liczbę punktów zanim dokona wydatku (na razie może zwracać True/False lub rzucać wyjątek, gdy brak środków).
Model zaopatrzenia: tutaj można na razie wprowadzić prostą reprezentację, np. listę lub słownik jednostek z informacją, czy są zaopatrzone. W przyszłości ten system będzie rozbudowany (np. generatory zaopatrzenia w miastach, linie zaopatrzeniowe, wpływ odcięcia od zaopatrzenia na parametry jednostek). Na ten moment wystarczy metoda is_supplied(unit) zwracająca True (domyślnie wszystko zaopatrzone), żeby miejsce na logikę było przewidziane.
Ewentualnie metoda update_supply_lines() – obecnie może być pusta lub tylko logować, że sprawdza zaopatrzenie. Docelowo miałaby obliczać, które jednostki są w zasiegu zaopatrzenia baz czy magazynów.
Klasa EconomySystem może być tworzona jako część globalnego stanu gry (np. w obiekcie GameState w core). Ewentualnie można zastosować wzorzec singletonu lub modułowe zmienne globalne, ale lepszą praktyką jest przekazywanie instancji do miejsc, które jej potrzebują, co poprawia czytelność i testowalność.
Dzięki temu szkieletowi, kod gry będzie już posiadał punkty zaczepienia do gospodarowania ekonomią. Gdy przyjdzie czas implementacji, programista wypełni istniejące metody szczegółową logiką (np. naliczanie punktów co turę, wpływ braku zaopatrzenia na możliwość ruchu jednostek, itp.), zamiast dodawać te elementy od zera w rozproszeniu po kodzie.
System sojuszy (negocjacje, losowania)
System sojuszy ma obsługiwać dyplomację w grze – nawiązywanie lub zrywanie sojuszy między stronami (np. czy dane państwo przyłączy się do naszej wojny), zapewne częściowo losowo lub w wyniku negocjacji. Aby przygotować grunt pod tę mechanikę, stworzymy moduł zarządzający relacjami między frakcjami. Proponowane zmiany:
Dodanie modułu engine/alliances.py z klasą AllianceSystem lub DiplomacySystem. Jej zadaniem będzie utrzymywanie stanu sojuszy oraz udostępnianie funkcji do zmiany tego stanu.
W klasie AllianceSystem można przewidzieć:
Reprezentację aktualnych relacji: np. strukturę danych przechowującą, które frakcje są sprzymierzone, a które w stanie wojny. Może to być macierz sąsiedztwa, słownik {faction: set(ally_factions)} lub lista krotek sojuszy. Na początek można wpisać tam stan początkowy zgodny z historią (np. Polska sojusznikiem Francji i Wielkiej Brytanii itp.) albo alternatywny wg scenariusza.
Metodę form_alliance(faction1, faction2), która dodaje sojusz między dwiema stronami (np. dodaje wpis do struktury i zwraca potwierdzenie). Póki co, może ona zawsze dodawać bez warunków lub mieć prosty warunek (np. jeśli nie były już sojusznikami).
Metodę break_alliance(faction1, faction2), analogicznie usuwającą sojusz (w przyszłości może sprawdzać konsekwencje).
Mechanizm negocjacji/losowania: tu warto dodać metodę attempt_alliance(faction1, faction2) która symuluje próbę zawarcia sojuszu. Obecnie może np. losować sukces z pewnym prawdopodobieństwem, generując wynik (sojusz zawarty lub odrzucony) i wywołując form_alliance jeśli wynik pozytywny. Można użyć modułu random do takiej symulacji. W przyszłości metoda ta będzie zapewne opierać się na bardziej złożonych czynnikach (np. ocena siły, korzyści, wydarzenia).
Możliwe, że gra będzie obsługiwała interfejs do negocjacji (np. okno dyplomacji). Na razie nie implementujemy interfejsu, ale warto żeby AllianceSystem posiadał czytelne metody, które GUI będzie mogło wywołać (np. kiedy gracz kliknie “Zaproponuj sojusz”).
Z takim szkieletem systemu sojuszy, gra będzie gotowa do wprowadzenia warstwy dyplomacji. Już teraz w kodzie można np. każdą turę wywołać alliances.attempt_alliance(RandomCountryX, RandomCountryY) żeby zasymulować jakieś wydarzenia dyplomatyczne (nawet jeśli tylko logowane). To pokaże, że mechanizm istnieje. Później dojdzie integracja z interfejsem (informowanie gracza o nowych sojuszach) i rozbudowa logiki decydującej o sojuszach.
System rozkazów (zlecanie zadań generałom)
System rozkazów ma umożliwić głównodowodzącemu (graczowi) wydawanie poleceń dla generałów, którzy dowodzą poszczególnymi zgrupowaniami wojsk. Zamiast ręcznie sterować każdą jednostką, gracz może delegować zadania – np. rozkaz obrony danego miasta dla generała X, natarcia na określonym kierunku dla generała Y, itp. To sugeruje potrzebę istnienia abstrakcji Rozkazu i mechanizmu przekazywania tych rozkazów do AI generałów. Proponowane zmiany:
Dodanie modułu engine/orders.py zawierającego definicję klasy Order oraz ewentualnie klas pokrewnych (np. różne typy rozkazów jako podklasy).
Klasa Order powinna zawierać podstawowe atrybuty opisujące rozkaz:
Typ rozkazu (np. atak, obrona, przegrupowanie, zwiad, itp. – warto zdefiniować enumerację lub stałe dla dostępnych typów).
Cel rozkazu: może to być wskazanie obszaru (hex na mapie, nazwa regionu) lub jednostki/przeciwnika, w zależności od typu. Na razie można użyć np. współrzędnych docelowego heksu lub ID jednostki.
Opcjonalnie priorytet lub limit czasu (czy rozkaz ma być wykonany natychmiast w następnej fazie generała, czy jest długoterminowy – to zależy od koncepcji).
Metoda execute() – można przewidzieć w klasie Order metodę, którą wywoła generał realizując ten rozkaz. W tej chwili będzie ona pusta lub będzie logować, np. print(f"Executing order {self.type} towards {self.target}"). W przyszłości implementacja będzie różna dla różnych typów (np. atak – ruszenie jednostek w stronę wroga; obrona – okopanie na pozycjach, itd.). Można do tego podejść na dwa sposoby:
Wzorzec Polecenie (Command) – wtedy każda podklasa Order nadpisuje execute() inaczej.
Prostszym tymczasowo – użyć pola typu i w execute() dać if/elif na typ, żeby zawołać odpowiednie działania (to może być przebudowane później).
Klasa General (jeśli nie istnieje, utworzyć w core/actors.py lub podobnym) powinna mieć możliwość otrzymywania rozkazów. Na przykład atrybut current_orders (lista lub kolejka rozkazów) oraz metodę assign_order(order: Order). W tej metodzie generał dodaje rozkaz do swojej listy.
W szkielecie, generał w swojej turze (General.take_turn() wywoływane w systemie tur) mógłby sprawdzać, czy ma rozkaz i jeśli tak, wywoływać order.execute(). Ponieważ pełna AI generała nie jest wymagana teraz, możemy po prostu wypisać komunikat, że generał X wykonuje rozkaz Y.
Dla spójności, można dodać też klasę HighCommand lub wykorzystać istniejącą reprezentację gracza, by wydawanie rozkazów generowało obiekty Order kierowane do odpowiednich generałów. Np. w GUI (w przyszłości) gracz wybierze generała i akcję – wtedy kod GUI wywoła general.assign_order(new Order(...)).
Ten szkielet sprawi, że mechanizm rozkazów będzie obecny w strukturze projektu. Choć obecnie nie zmieni rozgrywki (gdyż AI generałów jest symboliczne), to stanowi podstawę do późniejszego zaimplementowania złożonych zachowań. Co istotne, sam fakt istnienia klasy Order i metody General.assign_order pozwala już pisać kod w innych częściach gry zależny od tych interfejsów (np. system tur może przekazywać rozkazy z fazy głównodowodzącego do faz podkomendnych generałów).
System zwiadu i nalotów
Zwiad i naloty to elementy związane głównie z siłami powietrznymi lub specjalnymi akcjami – umożliwiają odkrywanie pozycji wroga (rozpoznanie) oraz atakowanie celów z dystansu (naloty bombowe). W grze strategicznej prawdopodobnie będą to akcje dostępne w określonych warunkach (np. gracz może wykonać ograniczoną liczbę misji zwiadowczych lub lotniczych na turę). Przygotujemy moduł obsługujący takie akcje. Proponowane zmiany:
Dodanie modułu engine/recon.py (lub engine/intelligence.py albo engine/air_ops.py – jeśli zwiad i naloty traktujemy jako część operacji powietrznych). Dla czytelności rozdzielimy jednak logikę wykrywania wroga (zwiad) od zadawania strat (nalot), choć mogą współdziałać.
Klasa np. ReconSystem w tym module, z odpowiedzialnością za wykonywanie misji zwiadowczej:
Metoda perform_recon(target_hex) – która symuluje przeprowadzenie rozpoznania nad wskazanym obszarem mapy. Póki co może losowo odkrywać obecność jednostek przeciwnika na tym heksie (np. jeśli mamy strukturę mapy i jednostek, ustawiałaby jakieś flagi “widoczny”). W szkielecie można ograniczyć się do wypisania “Recon mission over hex X executed”.
Można uwzględnić ograniczenia: np. licznik dostępnych misji na turę (pole recon_missions_left – zmniejszany przy użyciu, resetowany co turę przez TurnManager).
Klasa np. AirStrikeSystem (lub łączona AirSupportSystem), która obsłuży naloty:
Metoda perform_airstrike(target_hex) – symulacja ataku bombowego na wskazany heks. W szkielecie można założyć, że jeśli na tym polu jest jakaś jednostka przeciwnika, to otrzymuje obrażenia. Jako że nie implementujemy jeszcze systemu walki, można tu po prostu notować zdarzenie albo zmniejszać jakiś atrybut unit.health jeśli istnieje. Na razie jednak wystarczy np. losowy komunikat, czy nalot był skuteczny.
Również można mieć limit nalotów na turę (airstrikes_left).
Obie powyższe klasy mogą być zorganizowane jako osobne byty, lub jako jedna klasa AirOps z dwoma metodami. Decyzja może zależeć od tego, jak dokumentacja traktuje te akcje. Jeśli są powiązane (oba zużywają np. wspólny zasób "siły powietrznej"), można trzymać je razem.
Trzeba też zastanowić się nad integracją z interfejsem – docelowo gracz powinien móc wybrać opcję zwiadu czy nalotu z menu i wskazać cel na mapie. W szkielecie nie ma interfejsu, więc ewentualnie możemy wywoływać te metody testowo. Na przykład, w trakcie tury głównodowodzącego (w TurnManager) można automatycznie wywołać ReconSystem.perform_recon(random_hex) by zasymulować działanie.
Tak przygotowany system zwiadu/nalotów stworzy fundament pod reguły fog of war i wsparcia lotniczego w grze. W przyszłości będzie rozbudowany o rzeczywiste efekty (ujawnianie jednostek przeciwnika na mapie, zmniejszanie ich siły wskutek bombardowania itd.), ale już teraz struktura modułów i klas wymusza myślenie o tych działaniach jako oddzielnych od reszty, co poprawia modularność.
System widoczności jednostek (detekcja na heksach)
Widoczność jednostek, czyli popularny fog of war (mgła wojny), to mechanika determinująca, które jednostki lub obszary mapy są widoczne dla gracza, a które ukryte (dopóki nie zostaną wykryte przez zwiad lub znajdują się w zasięgu wzroku jednostek sojuszniczych). System ten będzie ściśle powiązany ze zwiadem, ale można go zaimplementować jako osobny moduł odpowiedzialny za przechowywanie informacji o tym, co jest aktualnie odkryte. Proponowane zmiany:
Utworzenie modułu engine/visibility.py z klasą np. VisibilitySystem lub FogOfWar.
Ta klasa może utrzymywać strukturę danych reprezentującą mapę widoczności. Na przykład, jeżeli mapa jest heksagonalna o wymiarach MxN, można trzymać tablicę 2D booleanów visible[hex] lub strukturę typu set zawierającą współrzędne odkrytych pól.
Metody do manipulacji widocznością:
reveal(hex) – oznacza dane pole jako widoczne (np. dodaje do zbioru widoczności). Może być wywoływane przez system zwiadu (gdy dokonamy rozpoznania na danym polu) lub przez jednostki (gdy jednostka wejdzie na pole lub w zasięg wzroku).
conceal(hex) – przeciwieństwo powyższego, choć w grach fog of war zazwyczaj raz odkryte pole zostaje widoczne (tylko jednostki mogą znikać z widoku). Możemy jednak potrzebować mechanizmu resetu widoczności na początku każdej tury (jeśli przyjmujemy, że w każdej turze widoczność zależy tylko od aktualnych pozycji jednostek i świeżego zwiadu).
is_visible(hex) – zwraca True/False czy dane pole jest widoczne. Tę metodę będą wykorzystywać np. moduły rysujące mapę, aby zdecydować czy pokazywać ikonki wroga.
Ewentualnie metoda update_visibility(friendly_units) – która ustawia widoczność na podstawie pozycji naszych jednostek. Może iterować przez listę naszych jednostek i dla każdej oznaczać wszystkie heksy w jej zasięgu wzroku jako widoczne (zasięg wzroku można na razie przyjąć stały, np. promień 2 heksów, albo wartość w atrybutach jednostki). Na razie implementacja może być prosta (np. każdy sojusznik odkrywa sąsiednie heksy).
Integracja: System widoczności powinien być aktualizowany na początku tury (lub po ruchach jednostek). Można np. w TurnManager.start_turn() wywołać visibility.update_visibility(player_units) i dodatkowo po wykonaniu misji zwiadowczej visibility.reveal(target_hex).
Ten komponent sprawi, że gra już teraz będzie mieć położone fundamenty pod mgłę wojny. Mimo że pełne ukrywanie/przedstawianie jednostek przeciwnika w GUI może wymagać dalszych zmian, samo istnienie VisibilitySystem pozwoli kontrolować, co gracz powinien widzieć. Przy zachowaniu edytora map i podstaw GUI, można nawet w tej chwili wykorzystać ten system: np. w edytorze lub trybie debug wywoływać reveal() na wszystkich heksach, by tymczasowo odkryć mapę. W docelowej grze funkcjonalność tego modułu będzie kluczowa dla realizmu i wyzwania rozgrywki.
Podsumowanie tworzenia szkieletów
Wszystkie powyższe systemy zostaną dodane jako puste lub częściowo zaimplementowane moduły w katalogu engine/. Ważne jest, by klasy i metody były nazwane zgodnie z ich przeznaczeniem, nawet jeśli na razie ich ciała są puste (pass) lub tylko drukują komunikaty. Dzięki temu inne części programu mogą już teraz odwoływać się do tych elementów, co:
Zapewni, że integracja między modułami jest przemyślana (np. TurnManager będzie świadomy istnienia EconomySystem czy VisibilitySystem i odpowiednio z nich korzystał w cyklu gry).
Ułatwi przyszłą pracę – programiści będą mieli wyraźne miejsca do uzupełniania logiki, zamiast dodawać wszystko od zera w chaotyczny sposób.
Pozwoli uniknąć dodawania tymczasowych, prowizorycznych rozwiązań – skoro struktura już jest, nie trzeba np. “na szybko” dopisywać obsługi sojuszy w jakimś innym module, tylko rozwijać AllianceSystem.
Przy implementacji szkieletów pamiętamy o zasadzie, by nie przekombinować architektury na zapas. Jak radzą doświadczeni programiści, lepiej skupić się na faktycznym problemie i potrzebach, zamiast od razu tworzyć zbyt skomplikowane struktury i wzorce, które mogą się okazać zbędne​
REDDIT.COM
. Dlatego nasze szkielety są możliwie proste i czytelne – mają zapewnić porządek, ale nie dodajemy np. trójpoziomowej abstrakcji tam, gdzie jedna klasa wystarczy (np. pojedynczy EconomySystem zamiast osobnych klas dla każdej waluty/zasobu na tym etapie).
Główny punkt startowy i menu GUI
Aby projekt był kompletny i gotowy do uruchomienia, potrzebny jest spójny punkt wejścia. Dotychczas prawdopodobnie program uruchamiał się przez edytor mapy lub inną część, ale nie miał centralnego menu. W refaktoryzacji wprowadzimy plik main.py w katalogu głównym, który będzie uruchamiał aplikację i prezentował użytkownikowi menu główne z wyborem dalszych akcji. Plan implementacji menu GUI (Tkinter):
Utworzenie main.py: Ten plik będzie zawierał funkcję main() lub blok ochronny if __name__ == "__main__": uruchamiający aplikację. Wewnątrz stworzymy główne okno Tkinter (tk.Tk()) i skonfigurujemy podstawowe menu.
Menu główne: Możemy zastosować prosty układ – np. cztery przyciski odpowiadające opcjom:
Nowa Gra – na razie może wyświetlać komunikat “Rozpoczęcie nowej gry” lub tworzyć obiekt Game i wywoływać jakąś testową pętlę tury. Ponieważ rozgrywka jeszcze nie jest w pełni zaimplementowana, można tu przewidzieć tylko inicjalizację stanu gry (np. załadowanie mapy domyślnej, utworzenie obiektów kluczowych jak TurnManager, EconomySystem itd.) oraz ewentualnie przejście do innej sceny (jeśli planujemy różne okna).
Edytor Mapy – kliknięcie powinno uruchomić istniejący edytor map. W praktyce, jeśli edytor mapy jest zrealizowany np. w module gui/map_editor.py jako klasa czy funkcja, to tu wystarczy go zaimportować i wywołać. Możliwe, że edytor jest osobnym oknem Tkinter lub canvasem – uruchomimy go w nowym oknie lub w tym samym głównym (np. zamykając menu). Ważne, by dostosować ścieżki importu (np. from gui import map_editor zamiast starej lokalizacji) i upewnić się, że po refaktoryzacji edytor map dalej działa poprawnie.
Edytor Żetonów – analogicznie, otwiera moduł do edycji/przeglądu jednostek. Jeśli to oddzielne narzędzie, uruchamiamy je podobnie jak edytor mapy. Być może edytor żetonów pozwala dodawać/usuwać typy jednostek czy zmieniać ich ikony – on również musi zostać przeniesiony do gui/ i zaktualizowany, a jego wywołanie nastąpi z menu głównego.
Wyjście – zamyka aplikację (root.destroy() w Tkinter).
Realizacja interfejsu: Można skorzystać z prostych widgetów Tkintera:
Użyć klasy tk.Frame lub bezpośrednio głównego okna i wstawić w nim przyciski (tk.Button) dla każdej opcji menu.
Można nadać proste style, ustawić tytuł okna (np. “Kampania Wrześniowa 1939”).
Jeśli to trywialne menu, nie potrzebujemy menu paska narzędzi, wystarczą przyciski centralnie.
Przyciski wywołają odpowiednie funkcje obsługi (np. start_new_game, open_map_editor, etc., które z kolei uruchomią właściwe procedury).
Integracja z resztą kodu: W funkcji startującej nową grę, po inicjalizacji można ewentualnie przejść do innego okna (np. głównego okna gry) – ale ponieważ pełna gra nie jest gotowa, tymczasowo można po prostu uruchomić np. jedną turę w konsoli lub wyświetlić komunikat “Gra w przygotowaniu”. Najważniejsze, żeby menu działało i było punktem centralnym.
Dlaczego Tkinter? Tkinter jest biblioteką standardową Pythona do GUI – nie wymaga dodatkowych instalacji, więc od razu zapewni działające okienko dla projektu. W przyszłości można rozważyć bardziej zaawansowane GUI (np. Pygame dla animowanej grafiki, Qt/GTK dla rozbudowanego interfejsu), ale na prototypowym etapie Tkinter wystarczy, by mieć okna i obsługę zdarzeń myszki/klawiatury. Po dodaniu menu głównego, uruchomienie gry w VS Code (lub innym środowisku) będzie polegało na wywołaniu python main.py. Pojawi się okno menu, z którego dostępne będą edytory oraz (docelowo) gra. To dużo wygodniejsze niż osobne uruchamianie skryptów edytora czy debugowanie bez GUI. Dodatkowo, jest to bardziej przyjazne dla użytkownika końcowego – nawet jeśli projekt trafi do innych testerów, od razu będą mieli intuicyjny start.
Zachowanie funkcjonalności edytora mapy i żetonów
Jednym z kluczowych wymagań jest, aby po refaktoryzacji nie utracić żadnych funkcji, zwłaszcza działającego edytora map i edytora żetonów. Te narzędzia najpewniej są już zaimplementowane w oryginalnym projekcie, z własnymi interfejsami do tworzenia/edytowania map hex i rozmieszczania jednostek. Refaktoryzacja musi te edytory wdrożyć do nowej struktury i upewnić się, że nadal działają poprawnie. Kroki zapewniające zachowanie edytorów:
Lokalizacja kodu edytorów: Najpierw identyfikujemy w starym projekcie pliki odpowiadające za edytor mapy (map_editor, editor_mapy.py czy podobne nazwy) oraz edytor żetonów. Te pliki zostaną przeniesione do katalogu gui/ (bo są elementem interfejsu).
Aktualizacja ścieżek i importów: Po przeniesieniu, wewnątrz kodu edytorów trzeba poprawić importy zależnie od nowej struktury. Jeśli np. edytor mapy wcześniej importował moduł map z tego samego folderu, teraz powinien importować core.map lub engine.map (w zależności, gdzie klasa mapy trafiła). Również dostęp do zasobów (grafiki, dane) powinien odwoływać się do nowego assets/ lub data/. Przykładowo, jeśli edytor wczytywał pliki obrazów z lokalnego katalogu, teraz ścieżka może być assets/tiles/terrain.png itp. W Pythonie można to załatwić dynamicznie (np. konstrukcja ścieżki oparta o lokalizację pliku __file__), ale najprościej na razie wpisać ścieżki względne do projektu.
Uruchamianie edytorów z menu: Jak wspomniano wyżej, menu główne będzie wywoływać funkcje startujące edytory. Można np. w module gui/map_editor.py zdefiniować funkcję open_map_editor() która tworzy okno edytora i uruchamia pętlę Tkinter dla niego. Podobnie dla żetonów. Wtedy main.py będzie mieć from gui import map_editor i przy kliknięciu przycisku: map_editor.open_map_editor(). To wymaga, by kod edytora był napisany tak, by nie uruchamiał się automatycznie przy imporcie (dlatego dobrze opakować logikę w funkcję albo pod warunkiem if __name__ == "__main__":). W razie potrzeby, dostosujemy minimalnie kod edytora, by działał zarówno jako importowany moduł, jak i samodzielnie (to ułatwia testowanie).
Testy działania: Po zintegrowaniu edytorów w nowej strukturze, przetestujemy je manualnie:
Uruchomienie menu, kliknięcie Edytor Mapy – powinna otworzyć się znana funkcjonalność edytora. Sprawdzamy, czy da się narysować mapę, zapisać ją, wczytać ponownie (jeśli te funkcje istniały), czy ikonki żetonów się wyświetlają (co potwierdzi poprawność ścieżek do assets).
Uruchomienie Edytor Żetonów – sprawdzamy wyświetlanie listy jednostek, edycję ich parametrów czy co tam było dostępne.
Wprowadzamy jakieś zmiany (np. dodanie nowego typu jednostki, nowej mapy) i upewniamy się, że są zapisywane poprawnie w data/ nowego projektu.
Zachowanie formatów plików: Jeśli edytor mapy/żetonów zapisuje dane do plików (np. .map dla map, czy .unit dla jednostek), zadbamy, aby ścieżki i formaty się nie zmieniły, chyba że wymaga tego unifikacja danych. Lepiej jednak nie zmieniać formatu w trakcie refaktoryzacji – to ogranicza ryzyko zepsucia zgodności. Można zawsze zostawić konwersję danych na później, a teraz skupić się na strukturze kodu. Dlatego np. jeśli mapy były w folderze maps/ i edytor tam zapisuje, przeniesiemy ten folder do data/maps/ i poinstruujemy edytor, że nowa ścieżka bazowa to data/maps/, ale sam format .map pozostaje ten sam.
Dzięki takiemu podejściu, po refaktoryzacji użytkownik końcowy (czyli np. projektant scenariuszy) nie odczuje negatywnych skutków zmian – edytory nadal działają jak wcześniej, może jedynie pliki znajdują się w nieco innych miejscach (co możemy opisać w dokumentacji). Mamy więc pewność, że pełna dotychczasowa funkcjonalność została zachowana, co było warunkiem koniecznym.
Infrastruktura pod dostępność i mikrotransakcje
Chociaż te elementy nie są częścią bieżącej rozgrywki, już teraz warto zaplanować architekturę pod ich przyszłe dodanie. Dzięki temu ich implementacja będzie mniej inwazyjna. Wprowadzimy więc pewne struktury (być może na razie puste) związane z dostępnością oraz mikrotransakcjami.
Dostępność (moduł dla niewidomych/niesłyszących graczy)
Dostępność w grach oznacza, że gracze z niepełnosprawnościami (np. niewidomi, słabowidzący, niesłyszący) mogą w nie grać dzięki dodatkowym ułatwieniom. W przypadku naszej gry strategicznej, warto pomyśleć o dwóch głównych aspektach:
Wsparcie dla niewidomych: np. interfejs audio, który odczytuje ważne informacje (stan jednostek, mapy) za pomocą syntezatora mowy, oraz alternatywne sterowanie klawiaturą.
Wsparcie dla niesłyszących: np. napisy dla komunikatów dźwiękowych, czytelne oznaczenia wizualne zamiast sygnałów dźwiękowych.
Proponowane działania:
Utworzenie pakietu/katalogu accessibility/ z plikiem accessibility.py lub kilkoma modułami dedykowanymi różnym aspektom. Przykładowo:
screen_reader.py – szkielet interfejsu do czytania ekranu. Można tu zdefiniować klasę ScreenReaderInterface z metodami typu speak(text) (obecnie może po prostu drukować na konsolę lub logować tekst, który powinien być odczytany). W przyszłości zaimplementuje się tu integrację z biblioteką TTS (text-to-speech).
visual_cues.py – klasa VisualNotifier która np. potrafi wyświetlać dodatkowe symbole/grafiki na ekranie dla dźwięków. Na razie może to być puste.
Zastanowienie się nad architekturą komunikatów: Dobrą praktyką jest, by gra korzystała z centralnego systemu wydarzeń/komunikatów dla rzeczy, które dzieją się w grze (np. “jednostka X zaatakowała Y”, “zdobyto miasto Z”). Wtedy moduł dostępności mógłby się podpiąć pod takie wydarzenia i odpowiednio reagować (np. przekazując je do syntezatora mowy). W ramach refaktoryzacji możemy już wprowadzić wstępnie taką strukturę – np. w core stworzyć prostą klasę EventManager lub po prostu listę callbacków, do której będą mogły się rejestrować różne systemy (w tym moduł dostępności). Na razie niech to będzie szkic: np. globalna lista game_events_listeners i funkcja notify_event(event_text) w core.events. Przyszłe systemy, w tym accessibility.screen_reader, mogą dodać tam swoje funkcje (które np. wywołują speak(event_text)). To rozwiązanie ułatwi dodanie dostępności, ale też logiki AI czy zapisu powtórek w przyszłości.
Integracja z GUI: Możemy dodać opcje w menu (na przyszłość) typu “Włącz tryb dla niewidomych”, która to spowoduje aktywację naszego ScreenReaderInterface. Już teraz możemy taką opcję umieścić w menu (np. jako nieaktywny jeszcze przycisk albo jako wpis w menu głównym z dopiskiem “(w budowie)”).
Wsparcie dla niesłyszących: jeżeli gra ma dźwięki (np. alarm o rozpoczęciu tury, odgłosy walki), w przyszłości trzeba zapewnić ich opis tekstowy. Na razie możemy zrobić listę potencjalnych dźwięków i przygotować mechanizm wyświetlania napisów – np. w module visual_cues metodę show_caption(text) (pusta implementacja na razie). Dodatkowo, upewnijmy się, że wszelkie informacje przekazywane graczowi nie opierają się wyłącznie na dźwięku – ale ponieważ nasza gra jest głównie planszowa, zapewne większość informacji jest graficzna lub tekstowa już teraz.
Planowane zmiany dotyczące dostępności nie wpłyną na obecną rozgrywkę (są odseparowane), ale tworzą miejsce w projekcie na te funkcje. Dzięki temu, gdy pojawi się np. specjalista od dostępności w zespole, będzie on miał przygotowany moduł do pracy, zamiast przebudowywać cały projekt pod kątem integracji tych funkcji.
Mikrotransakcje (podstawa pod sklep/dodatki)
Mikrotransakcje w kontekście tej gry mogą oznaczać dodatkową zawartość do kupienia (np. nowe scenariusze, kampanie, unikalne jednostki) albo model free-to-play z pewnymi płatnymi opcjami. Już na etapie prototypu możemy przemyśleć, jak odseparować logikę gry od logiki płatności, tak aby wprowadzenie sklepu nie wymagało modyfikowania samej rozgrywki. Proponowane działania:
Utworzenie modułu store/microtransactions.py z klasą np. Store lub PurchaseManager. Ta klasa będzie odpowiadać za wszelkie transakcje finansowe i odblokowywanie treści.
W ramach szkieletu, klasa Store może zawierać:
Listę dostępnych towarów/doładowań – np. słownik items = {"DLC1": 9.99, "SkinA": 1.99} lub coś w tym stylu. To może być docelowo wczytywane z pliku konfiguracyjnego lub pobierane z serwera, ale na razie możemy wstawić na sztywno parę pozycji.
Metodę purchase(item_name) – która reprezentuje próbę zakupu. Na razie nie mamy systemu płatności, więc może ona tylko wypisywać “Zakupiono item_name” albo “Dodano do konta item_name” i założyć, że zawsze się udaje. Można dodać warunek, że jeśli item nie istnieje w items, to zwraca False.
Metodę is_owned(item_name) – zawsze zwracającą True na razie (albo False dla niekupionych – ale wtedy trzeba utrzymywać stan posiadanych przedmiotów w jakiejś liście owned_items). Docelowo ta funkcja będzie sprawdzać np. plik z zapisanymi zakupami lub pytać serwer, czy użytkownik kupił dany element.
Integracja z resztą gry:
Jeśli planujemy dodatkowe kampanie jako płatne DLC, to mechanizm wyboru scenariusza (np. w menu Nowa Gra) może pytać Store.is_owned("DLC1") – jeśli False, wyświetli kłódkę lub komunikat “kup aby zagrać”. Na razie możemy założyć, że wszystko jest dostępne (albo zasymulować że coś jest zablokowane).
Możemy dodać w menu głównym przycisk Sklep (nawet jeśli jeszcze nieaktywny). Kliknięcie mogłoby otwierać okno z listą itemów i możliwością zakupu (to raczej melodia przyszłości, ale szkicowo: nowe okno Tkinter z listą nazw i cen z Store.items i przyciskiem “Kup” obok każdego).
Ważne jest, by w pozostałym kodzie nie było zakodowanych na sztywno elementów zależnych od mikropłatności. Zamiast np. od razu dodawać nowe jednostki premium do listy jednostek, możemy wczytywać listę jednostek dynamicznie i po refaktoryzacji dodać komentarz lub hook, że tu będzie filtracja treści po posiadaniu DLC. Na razie pełna zawartość jest dostępna.
Bezpieczniki: moduł store jest całkowicie niezależny. Jeśli gra działa offline i nie interesuje nas sklep, po prostu nie korzystamy z niego. To odseparowanie jest ważne, by ewentualne błędy czy zmiany w systemie płatności nie wpływały na stabilność rozgrywki samej w sobie.
Podobnie jak w przypadku dostępności, ten element nie zmienia obecnego działania gry (jeszcze nic nie jest “płatne”), ale architektura jest przygotowana. Gdy zdecydujemy się wprowadzić monetyzację, będzie jasne, gdzie dodawać kod obsługi płatności. Być może integracja z API jakiegoś sklepu czy platformy (Steam, Itch.io, itp.) będzie wymagała dodatkowych narzędzi, ale wtedy wystarczy rozbudować moduł store, bez rozpraszania logiki finansowej po całym projekcie.
Podsumowanie i rezultat refaktoryzacji
Po wykonaniu powyższych kroków, powinniśmy otrzymać kompletny projekt gry w nowej strukturze, gotowy do uruchomienia i dalszego rozwoju. Kluczowe osiągnięcia refaktoryzacji to:
Czytelna struktura katalogów – wyraźnie oddzielone warstwy: logika (core/engine), interfejs (gui), dane (data), zasoby (assets), rozszerzenia (accessibility, store). Taka organizacja jest zgodna z zaleceniami doświadczonych twórców gier, by utrzymać porządek i grupować powiązane elementy​
REDDIT.COM
.
Brak duplikacji – wszystkie zasoby graficzne i konfiguracyjne są unikalne, a kod podzielony tak, by nie powielać tych samych funkcjonalności w różnych miejscach. Zgodnie z zasadą DRY każdy fragment logiki ma jedno źródło, co zmniejsza ryzyko błędów i ułatwia wprowadzanie zmian​
MEDIUM.COM
.
Szkielety przyszłych systemów – projekt zawiera już placeholdery dla wszystkich głównych mechanik rozgrywki przewidzianych w dokumentacji: tury z podziałem na fazy, ekonomia i zaopatrzenie, sojusze, rozkazy, zwiad/naloty, widoczność. Dzięki temu dalsza praca skupi się na uzupełnianiu tych modułów zamiast restrukturyzacji od zera.
Działający edytor map i jednostek – mimo dużych zmian w układzie plików, istniejąca funkcjonalność nie została utracona. Edytory zostały zintegrowane z nowym projektem i można z nich korzystać poprzez menu główne. To oznacza, że mapa może być nadal tworzona i modyfikowana graficznie, a zestawy jednostek konfigurowane, co jest ważne dla utrzymania ciągłości prac nad grą.
Punkt startowy aplikacji – plik main.py zapewnia łatwe uruchomienie projektu. Menu główne daje dostęp do wszystkich istotnych modułów (gra/edytory), co poprawia ergonomię użytkowania i testowania.
Przygotowanie na rozszerzenia – uwzględnienie w strukturze modułów dla dostępności i mikrotransakcji świadczy o proaktywności w projektowaniu. Nawet jeśli te funkcje będą dodane później, już teraz uwzględniono ich obecność architektonicznie, co zapobiegnie potencjalnym konfliktom i przerabianiu kodu w przyszłości.
Po refaktoryzacji należy przeprowadzić przegląd i test całości. Warto uruchomić projekt kilkukrotnie w różny sposób:
Bezpośrednio main.py (sprawdzenie menu, wyjście).
Z menu: uruchomienie edytora map, narysowanie prostej mapy, zapis.
Z menu: uruchomienie edytora żetonów, podgląd jednostek.
(Opcjonalnie) Symulacja nowej gry: choć gra nie jest ukończona, możemy spróbować wywołać TurnManager.start_turn() i zobaczyć w konsoli komunikaty z naszych skeletonów (np. że tura się rozpoczęła, generał X wykonuje rozkaz itp.). To upewni nas, że poszczególne systemy są poprawnie podłączone i nie generują wyjątków.
Refaktoryzacja, jak opisano, skupia się na organizacji i architekturze, nie zmieniając wyników działania gry. Użytkownik końcowy (gracz lub projektant scenariuszy) nie powinien zauważyć regresji – gra nadal zadziała jak poprzednio, ale zespół deweloperski zyska znacznie czytelniejszy, łatwiejszy w rozbudowie kod. Zgodnie z zasadą KISS (Keep It Simple, Stupid), utrzymano prostotę tam, gdzie to możliwe, unikając nadmiernego skomplikowania struktury​
REDDIT.COM
, jednocześnie dbając o przyszłą skalowalność. Efektem końcowym jest gotowy do pracy projekt, który można otworzyć w VS Code (lub dowolnym IDE) i od razu uruchomić. Dalsze prace – implementacja szczegółowych mechanizmów według dokumentacji koncepcyjnej – będą mogły przebiegać szybko, bo wszystkie moduły mają już swoje miejsce. Projekt jest zorganizowany, zgodny z założeniami dokumentacji i przygotowany na rozszerzenia, co spełnia wszystkie wymogi zadania refaktoryzacji.